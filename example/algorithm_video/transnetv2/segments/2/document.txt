Segment: 2
Time Interval: 00:00:10.500, 00:04:55.966
Closed Captions:
algorithms for coding interviews so the number one most common graph algorithm you may have expected this is depth first search dfs now the time complexity of this algorithm in most cases is going to be linear time in other words big o of n where n is going to be the number of nodes inside of our graph so if you're familiar with graphs you know that graphs are made up of nodes which can contain values and also edges which connect the nodes together if we have n nodes then dfs runs in big o of n time now what kind of data structures are needed for dfs well if you are going to do this recursively the only data structure you will most likely need is going to be a hash set the hash set is specifically to basically detect a cycle because depth for search is about traversing a graph so for example if we start at this position we want to traverse the graph we go to the next node we go to a another node over here suppose these two nodes were connected then we travel to this node and then we'd get here and then we'd travel back to this node which would get us stuck into a cycle right now we don't want to stay stuck in this cycle forever which is why hash sets are required in many cases for the dfs algorithm on a generic graph if you are doing this recursively you will not need a stack because the recursion handles that for you but if you do not do this recursively you can optionally decide to use a stack for dfs problems now let's suppose we were doing a dfs on this graph let's say starting from a now obviously this looks exactly like a tree and yes it is a tree but we know that trees are just special cases of graphs so this is still a generic graph now if we were starting here at this a node and we were doing a dfs what would be the output well the output we'd first process the first node we'd get an a then we'd go to the next node right now dfs works basically going depth first so so it's depth first so we we do b now next we go to c you can see that this is definitely depth first we're going as deep as we can in one direction so we get to c now now we can't go any farther from c left or right so we go back up and we go to the next node that was available to us the farthest down depth first right d and now there's no more nodes anywhere left over here so then we go to the next node that was available which was e we have done the entire graph and this is the output abcde next let's go to our second algorithm bfs or breadth first search and as the name implies this is also a searching algorithm which is basically designed to traverse a graph now this is going to be slightly different than depth first search mainly in the order that it traverses the values which is what we're going to see when i show you the output how d bfs would traverse this graph but the time complexity actually of this graph is going to be the same as dfs because we're going to visit each node at most once so the time complexity is going to be big o of n where n is the number of nodes in the graph the data structures typically needed for this algorithm and it's usually not implemented recursively so it usually requires a q data structure a double-ended queue usually again in in our graph we could have a cycle similar to the dfs case so we don't want to get stuck in a loop where we go to one node go to the next node and then just stay stuck in there forever because we don't want to visit the same node twice how can we avoid that same case same way that we did in dfs which is using a hash set to detect duplicate nodes and bfs is kind of the opposite of dfs so let's say we start at the same first node right we start at a so let's add a to the output now instead of going the farthest we can in one direction like we did before like going to b and then going to c let's do breadth first search right breath meaning everything that's close to us basically we're gonna do this layer first right we're gonna we're gonna traverse this entire layer and then we're gonna traverse the next layer and then keep doing that until we run out of layers to traverse so let's go let's first go to b so b is gonna be processed adding it to the output then let's go to e adding this to the output and you can see that this is a different output than we had when we ran dfs so this is a different ordering that we're going to traverse these nodes in so we've done the second layer over here let's do the next layer over here so we'll do c and then d so let's add c and d to the output and then you can see everything has been processed in the entire graph we had a slightly different output than we did with the dfs case so the third
Image Analysis:
Common Elements:
1. Both images contain a graph with nodes labeled A, B, C, D, and E.
2. There are titles at the top of each image indicating that they are related to algorithms â€“ specifically, "Depth First Search (DFS)" in the first image and "Breadth First Search (BFS)" in the second.
3. Each image includes a section for "Time" and "Data Structures," though only the second image has these fields filled in.
4. The second image shows a specific traversal order in the "Output" section ("A B E C D"), which is a result of the BFS algorithm.

Themes Suggested:
The images are themed around computer science, specifically the study of graph traversal algorithms. The first image is set up to describe the Depth First Search algorithm, while the second image describes the Breadth First Search algorithm. The BFS image also includes annotations about the time complexity (O(n)) and the data structures used (Queue, HashSet).

Patterns or Consistent Messages:
The consistent message across both images is the illustration and comparison of two fundamental graph traversal algorithms. The BFS image shows a completed example, indicating the order in which nodes would be visited using this approach.

Summary of Scene's Likely Narrative:
The overall narrative conveyed by the images is an educational explanation of two different algorithms used to traverse or search through a graph. The first image is an incomplete template for explaining DFS, where one would expect to see the traversal order that results from following the DFS strategy. The second image demonstrates the BFS algorithm, providing the traversal order, time complexity, and data structures used. Together, these images would likely be part of a tutorial or instructional material explaining how these algorithms work and highlighting the differences between depth-first and breadth-first strategies in traversing or searching a graph.